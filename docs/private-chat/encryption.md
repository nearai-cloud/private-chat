# User Data Encryption in Private Chat

## Overview

Implements **per-user data encryption** with zero-knowledge architecture where developers, cloud providers, and Phala Network cannot access user chat data.

## Why This Implementation Protects User Data

### Core Security Principles

1. Per-User Encryption Keys (AES-256-GCM)
2. External Key Management via Phala TEE
3. Zero-Knowledge Design
4. Transparent Encryption
5. Backward Compatibility
6. Complete TEE Deployment

### Security Guarantees

- Developers cannot access user data
- Cloud providers cannot read conversations
- Phala Network cannot decrypt data
- Database compromises mitigated
- Forward secrecy maintained
- Frontend runs in TEE
- Hardware-level security protection

## Architecture

### High-Level Flow

```
User Chat -> Application -> Encryption Layer -> Database (Encrypted)
                    |
                    v
            Phala Key Service (TEE)
```

### Components

1. **Chat Encryption Proxy** (`chat_encryption_proxy.py`) - Transparent wrapper with fallback handling
2. **User Encryption Service** (`user_encryption.py`) - AES-256-GCM implementation with key caching

3. **Phala Key Service** (External TEE)
   - Secure key generation and storage
   - TEE-based key decryption service
   - Hardware-protected key operations

## Technical Implementation

### Encryption Specification

- **Algorithm**: AES-256-GCM
- **Key**: 256 bits, **Nonce**: 96 bits (random)
- **Encoding**: Base64

### Data Flow

**Encryption**: User data → Get/generate key from Phala KMS → JSON serialize → AES-256-GCM encrypt → Base64 encode → Store

**Decryption**: Retrieve → Base64 decode → Extract nonce → Get key from KMS (cached) → AES-256-GCM decrypt → Parse JSON

### Key Management Architecture

#### Phala Key Service Integration

Integrates with Phala TEE for key management:

```yaml
# Docker Compose Configuration
services:
  key-service:
    image: danielwpz/seal-cvm:0.5
    volumes:
      - /var/run/dstack.sock:/var/run/dstack.sock
    
  private-chat:
    environment:
      ENABLE_CHAT_ENCRYPTION: true
      KEY_SERVICE_BASE_URL: http://key-service:3001
```

#### Key Lifecycle

1. **Key Generation**: When a user first needs encryption, a new key is generated by Phala KMS
2. **Key Storage**: Encrypted key is stored in the database (`user_data_keys` table)
3. **Key Retrieval**: Keys are decrypted on-demand by the TEE service
4. **Key Caching**: Decrypted keys are cached in memory for performance
5. **Key Rotation**: Keys can be rotated through the KMS interface

### Transparent Proxy Implementation

The `ChatTableEncryptionProxy` class wraps all database operations:

```python
class ChatTableEncryptionProxy(ChatTable):
    def insert_new_chat(self, user_id: str, form_data: ChatForm):
        # Encrypts chat data before storage
        self._store_encrypted_chat(chat_record, form_data.chat, user_id)
        
    def get_chat_by_id(self, id: str):
        # Decrypts chat data after retrieval
        return self._create_chat_model_from_db_record(db_record)
```

### Security Features

#### Configuration
- `ENABLE_CHAT_ENCRYPTION=true`
- Backward compatible with plaintext data
- Graceful fallback on encryption failures

#### Protected Data
- Chat content, titles, and user metadata

#### Performance
- In-memory key caching, lazy loading, batch operations

## Configuration

### Environment Variables

```bash
# Enable per-user encryption
ENABLE_CHAT_ENCRYPTION=true

# Phala Key Management Service URL
KEY_SERVICE_BASE_URL=http://key-service:3001

# Database configuration
DATABASE_URL=postgresql://user:pass@host:port/db
```

### Deployment with Phala Network

System runs **entirely within Phala's TEE**, unlike traditional cloud deployments:

```yaml
services:
  key-service:
    image: danielwpz/seal-cvm:0.5
    container_name: key-service
    volumes:
      - /var/run/dstack.sock:/var/run/dstack.sock
    restart: unless-stopped

  private-chat:
    image: danielwpz/private-chat:0.4
    container_name: private-chat
    environment:
      ENABLE_CHAT_ENCRYPTION: true
      KEY_SERVICE_BASE_URL: http://key-service:3001
```

**TEE Benefits:**
- Hardware-protected enclaves
- Frontend runs in TEE (not user devices)
- Zero trust architecture
- Cryptographic code verification
- Host OS memory protection

## Security Considerations

### Threat Model

**Protected Against:** Database breaches, cloud surveillance, insider threats, network interception, host OS attacks, infrastructure attacks

**Attack Surface:** Memory dumps (TEE only), side-channel attacks (mitigated), physical hardware attacks, fully compromised client endpoints

**Note:** TEEs may mitigate certain client-side risks by running the frontend in hardware-protected enclaves rather than user devices, but cannot protect against fully compromised endpoints or browsers.

## Privacy Guarantees

**Privacy Guarantees:**
- User conversations remain private with database access
- Developers cannot read user content
- Cloud providers cannot access plaintext
- Phala operators cannot decrypt data
- Enhanced regulatory compliance

AES-256-GCM + per-user keys + TEE management maintains zero-knowledge throughout data lifecycle.

## Migration and Compatibility

The system ensures seamless encryption integration:

- Backward compatibility with existing unencrypted chats
- Automatic encryption for new chats
- Graceful fallback on encryption failures
- Transparent encryption/decryption

Privacy-conscious users benefit from strong encryption without workflow disruption.
